---
description:
globs:
alwaysApply: true
---
# Project Overview: Laravel 12 Event Platform

This document outlines the structure and conventions for this Laravel 12 project.

## Key Configuration Files:
- **`composer.json`**: Manages PHP dependencies and project metadata. See [composer.json](mdc:composer.json) for details.
- **`package.json`**: Manages Node.js dependencies for frontend assets. See [package.json](mdc:package.json) for details.

## Directory Structure:
This project follows the standard Laravel directory structure:
- **`app/`**: Contains the core code of the application (Models, Controllers, Providers, etc.).
  - **`app/Actions`**: Houses single-responsibility action classes.
  - **`app/DataTransferObjects`**: Contains DTOs, typically built with `spatie/laravel-data`.
  - **`app/Services`**: Holds service classes that encapsulate business logic.
- **`bootstrap/`**: Contains framework bootstrapping scripts and compiled files.
- **`config/`**: Stores all application configuration files.
- **`database/`**: Holds database migrations, seeders, and factories.
- **`public/`**: The web server's document root, containing the `index.php` entry point and compiled assets.
- **`resources/`**: Contains views (Blade templates), raw assets (CSS, JS), and language files.
  - **`resources/js/Pages/Admin/{Entity}`**: Convention for Inertia.js Vue components for admin CRUD interfaces.
- **`routes/`**: Defines all application routes (`web.php`, `api.php`, etc.).
- **`storage/`**: Stores compiled Blade templates, file-based sessions, file caches, and other files generated by the framework.
- **`tests/`**: Contains automated tests (unit, feature).
- **`vendor/`**: Contains Composer dependencies.
- **`node_modules/`**: Contains NPM dependencies.

## Development Methodology: Test-Driven Development (TDD)

This project follows **Test-Driven Development (TDD)** methodology. The TDD cycle consists of:

1. **Red**: Write a failing test that describes the desired functionality
2. **Green**: Write the minimal code necessary to make the test pass
3. **Refactor**: Improve the code while keeping tests green

### TDD Guidelines:

- **Test First**: Always write tests before implementing functionality
- **Small Steps**: Make incremental changes with frequent test runs
- **Test Coverage**: Aim for comprehensive test coverage of business logic
- **Test Types**:
  - **Unit Tests**: Test individual classes, methods, and functions in isolation
  - **Feature Tests**: Test complete user workflows and API endpoints
  - **Integration Tests**: Test interactions between different components
- **Test Organization**: Tests are located in the `tests/` directory with `Unit/` and `Feature/` subdirectories
- **Test Naming**: Use descriptive test method names that explain what is being tested
- **Test Data**: Use factories and seeders for consistent test data

### Testing Code Protection:

**⚠️ CRITICAL: Unless explicitly indicated otherwise, NEVER modify, delete, or change existing testing code.** This includes:
- Test files in `tests/Unit/` and `tests/Feature/`
- Factory files in `database/factories/`
- Test-specific seeders
- PHPUnit configuration files
- Test helper classes and traits

Testing code should only be modified when:
1. Explicitly requested by the developer
2. Adding new tests for new functionality
3. Fixing broken tests due to intentional API changes
4. Refactoring tests as part of a specific testing improvement task

## Coding Standards:
The application aims to adhere to **SOLID principles** and the principles of **Clean Code** to ensure maintainable, scalable, and robust code. Key principles include:

-   **Meaningful Naming**: Use descriptive and unambiguous names for variables, functions, and classes. Avoid single-letter variables or cryptic abbreviations.
-   **Function Simplicity**: Keep functions short and focused on a single task (Single Responsibility Principle).
-   **Avoid Duplication (DRY - Don't Repeat Yourself)**: Refactor code to eliminate redundant logic.
-   **Side Effect Management**: Minimize or eliminate side effects in functions.
-   **Clarity and Expressiveness**: Write code that is easy to understand at a glance.
-   **Consistent Formatting**: Maintain consistent code formatting and style throughout the project.
-   **Error Handling**: Implement robust error handling and provide meaningful error messages.
-   **Comments**: Use comments sparingly and only when necessary to explain the *why* behind the code, not the *what*.
-   **Testing**: Write thorough unit and feature tests following TDD principles to ensure the code functions as expected.
-   **Modularization**: Structure code into modular components with clear separation of concerns.
-   **Avoid Global Variables**: Minimize the use of global variables to reduce side effects.
-   **KISS (Keep It Simple, Stupid)**: Apply this principle to keep code concise and straightforward.
-   **Rule of Three**: If you find yourself writing similar code three times, consider refactoring it into a reusable function or abstraction.
-   **Source Code Structure**: Organize code in a way that reflects the logical structure of the problem being solved.
-   **Object and Data Structure**: Design objects and data structures that are easy to understand, use, and maintain.
-   **Clarity Over Cleverness**: Prioritize readability and simplicity over overly complex or "clever" solutions.

# Modular Monolithic Design Approach

This project adopts a modular monolithic design. The application will be structured by breaking down the overall system into distinct, self-contained modules.

Each module will encapsulate a specific business capability or domain, aiming for:
- **High Cohesion**: Components within a module are closely related.
- **Low Coupling**: Modules interact with each other through well-defined interfaces, minimizing direct dependencies.

This approach helps in managing complexity, improving maintainability, and allowing for better team scalability as the project grows, while still retaining the deployment simplicity of a monolith.

Key architectural patterns include:
- **Thin Controllers, Fat Models**: Controllers should be lean, delegating business logic to models and other service layers. Models will contain the bulk of the business logic related to data persistence and relationships.
- **Actions**: Single-responsibility classes that encapsulate a specific piece of business logic, often corresponding to a single controller method or a complex operation. For new entities, actions (e.g., `UpsertEntityAction`) are typically created to handle Create/Update logic.
- **Services**: Classes that provide specific functionalities or business logic that doesn't neatly fit into a model or action. They help to keep controllers and models focused. For new entities, a corresponding service (e.g., `EntityService`) is often created to orchestrate actions and provide a comprehensive API for entity lifecycle management (CRUD operations like `createEntity`, `updateEntity`, `deleteEntity`, `findEntity`, `getAllEntities`).
- **Data Transfer Objects (DTOs)**: Simple objects used to transfer data between layers, particularly from requests to actions/services or from services/models back to controllers/responses. This promotes clear data contracts and immutability where appropriate. This project utilizes **`spatie/laravel-data`** for creating these DTOs, enhancing type safety and developer experience.

Following the creation of an entity model, migrations, and seeders, the typical **TDD workflow** involves:

### Backend Development (TDD Approach):
1.  **Write Tests First**: Create unit tests for the entity model, and feature tests for the expected API endpoints
2.  **Define DTOs**: Create a `Spatie\LaravelData\Data` object (DTO) in `app/DataTransferObjects/` to represent the data structure for creating/updating the entity
3.  **Test-Drive Actions**: Write tests for Action classes, then implement them in `app/Actions/{EntityName}/` (e.g., `UpsertEntityAction.php`) to handle the core business logic
4.  **Test-Drive Services**: Write tests for Service classes, then develop them in `app/Services/` (e.g., `EntityService.php`) that use the Action(s) and provide a clean API
5.  **Test-Drive Controllers**: Write feature tests for HTTP endpoints, then implement Controllers in `app/Http/Controllers/Admin/` (e.g., `EntityController.php`) which use the Service to handle requests and responses
6.  **Refactor**: Continuously refactor code while maintaining green tests

### Frontend Development:
7.  Developing frontend Vue components (typically in `resources/js/Pages/Admin/{EntityName}/` like `Index.vue`, `Create.vue`, `Edit.vue`) for the entity's CRUD interface, interacting with the tested controller endpoints

### Test Coverage Requirements:
- **Models**: Test relationships, scopes, mutators, accessors, and business logic methods
- **Actions**: Test all business logic paths, edge cases, and error conditions
- **Services**: Test orchestration logic and integration between actions
- **Controllers**: Test HTTP responses, validation, authorization, and error handling
- **DTOs**: Test validation rules and data transformation

## Frontend Development Conventions

- **Mobile-First Design**: The application is designed with a mobile-first approach, ensuring a seamless experience on smaller screens before scaling up to larger displays.
- **Reusable Components**: The frontend will be built with a strong emphasis on creating and utilizing reusable UI components. This ensures a consistent user experience, unified layout, and efficient development. Components should be designed for flexibility and composability.
- **Standardized CRUD Interfaces**: For entities requiring management, corresponding Inertia.js Vue components (e.g., `Index.vue`, `Create.vue`, `Edit.vue` pages) are typically created in the `resources/js/Pages/Admin/{Entity}` directory. These components interact with the backend through the defined Actions and Services via their respective Controllers.
- **Further Frontend Conventions**: For more detailed frontend conventions, including handling complex forms with translatable data and file uploads, refer to the [frontend.mdc](mdc:.cursor/rules/frontend.mdc) rule file.

## Project Requirements and Tasks:
- Project requirements and documentation are located in the `prd/` directory.
- Specific tasks and implementation details can be found in [prd/tasks.md](mdc:prd/tasks.md). Please refer to this file for ongoing development tasks.

## Task Management Process

When working on tasks from [prd/tasks.md](mdc:prd/tasks.md):
- **Starting a Task**: Before beginning work, the task status in [prd/tasks.md](mdc:prd/tasks.md) should be updated to "Processing".
- **Completing a Task**: Upon completion, the task status in [prd/tasks.md](mdc:prd/tasks.md) must be updated to "Done" (or "Completed").
- **Status Accuracy**: It is important to ensure task statuses are accurately maintained throughout the development lifecycle.

## Key Libraries and Their Design Implications

Several key libraries are utilized in this project, each influencing design and development practices:

- **`spatie/laravel-translatable`**:
    - **Purpose**: Provides an easy way to manage translatable model attributes.
    - **Design Implication**: Model fields intended for translation (e.g., name, description) must be defined as `JSON` type in database migrations. When accessing these attributes on a model, the library automatically provides the translation for the current application locale. Data for these fields is typically saved as a JSON object with locale keys (e.g., `{"en": "English Text", "zh-TW": "繁體中文文本"}`). The model must use the `Spatie\Translatable\HasTranslations` trait and define a `public array $translatable` property listing the translatable fields.
    - **Note on DTO Hydration and Interaction**:
        - When hydrating a `Spatie\LaravelData\Data` DTO from a model with translatable fields, if the DTO expects these fields as arrays (which is the recommended approach for consistency), ensure proper data transformation. This typically involves casting the translatable attribute to `'array'` in the model's `$casts` property (e.g., `protected $casts = ['name' => 'array'];`) and then converting the model to an array before DTO hydration (e.g., `YourData::from($model->toArray())`).
        - When a DTO receives data for translatable fields (e.g., from a frontend form), it should ideally receive it as a nested array (e.g., `name: {'en': 'Name EN', ...}`). This DTO then passes this structure to the action/service layer, which in turn provides it to the Eloquent model. `spatie/laravel-translatable` handles the persistence of this array into the JSON database column.

- **`spatie/laravel-permission`**:
    - **Purpose**: Manages user roles and permissions.
    - **Design Implication**: Requires the `HasRoles` trait to be added to the `User` model (or any model that needs role/permission assignment). Introduces database tables for roles, permissions, and their relationships. Access control can be implemented using provided model methods (e.g., `$user->hasRole('admin')`, `$user->can('edit articles')`) and Blade directives (`@role`, `@can`).

- **`spatie/laravel-data`**:
    - **Purpose**: Enables the creation of rich, type-safe Data Transfer Objects (DTOs).
    - **Design Implication**: DTOs are typically created in `app/DataTransferObjects` and extend `Spatie\LaravelData\Data`. This library facilitates easy creation of DTOs from various sources (e.g., HTTP requests, Eloquent models), handles data validation and casting, and promotes clear data contracts between different layers of the application.
    - **Translatable Fields in DTOs**: For fields that are translatable (managed by `spatie/laravel-translatable` in the model), the DTO should define these properties as `array` type (e.g., `public readonly array $name;`). Validation rules in the DTO should then target specific locales within this array (e.g., `rules() { return ['name.en' => 'required|string']; }`).
    - **Interaction with Frontend Forms (e.g., Inertia.js)**:
        - When receiving data from frontend forms, especially for complex scenarios involving translatable fields and file uploads, it's crucial that the structure of data submitted by the frontend aligns with the DTO's expected structure.
        - For translatable fields, the frontend (e.g., using `form.transform()` in Inertia.js) should send data as nested objects/arrays (e.g., `name: {'en': 'Name EN', 'zh-TW': '名稱繁體'}`). The DTO, structured as mentioned above, can then be hydrated directly using `YourData::from($request->all())`.
        - For detailed frontend conventions on preparing this data, see [frontend.mdc](mdc:.cursor/rules/frontend.mdc).
    - **Note on Hydrating from Translatable Models**: When creating a DTO from an Eloquent model that uses `spatie/laravel-translatable` for fields expected as arrays in the DTO (e.g., `public readonly array $name`), ensure the model data is correctly transformed. It's recommended to:
        1. Cast the translatable field to `'array'` in the Eloquent model's `$casts` property.
        2. Convert the model instance to an array using `$model->toArray()` before passing it to the DTO's `from()` method (e.g., `YourData::from($model->toArray())`). This helps avoid TypeErrors.

- **`spatie/laravel-medialibrary`**:
    - **Purpose**: Provides a robust and easy-to-use system for associating files with Eloquent models.
    - **Design Implication**: Models that need to manage media (e.g., images, documents) should implement the `Spatie\MediaLibrary\HasMedia` interface and use the `Spatie\MediaLibrary\InteractsWithMedia` trait. This replaces manual management of file paths or JSON-encoded image lists in model attributes. Media are organized into collections.
    - **Usage with DTOs**: In DTOs, uploaded files are typically instances of `Illuminate\Http\UploadedFile` (e.g., `public readonly ?UploadedFile $uploaded_main_image;`). Actions/Services then use methods like `$model->addMedia($uploadedFile)->toMediaCollection('collection_name');`. For displaying existing media, DTOs can hold instances of `MediaData` objects (a custom DTO representing `Spatie\MediaLibrary\MediaCollections\Models\Media`) or arrays of such objects.

- **`laravel/cashier`** (Stripe - *Note: Assumed for future use as it's not yet installed*):
    - **Purpose**: Offers an expressive, fluent interface to Stripe's subscription billing services.
    - **Design Implication**: The `User` model (or other billable models) must use the `Billable` trait.

- **`MCP Context7 Library Documentation`**:
    - **Purpose**: Provides tools to access up-to-date documentation for various libraries and frameworks directly within the development environment. This is useful for quickly looking up API details, usage examples, and best practices without leaving the IDE.
    - **Tools**:
        - `mcp_context7_resolve-library-id`: Resolves a human-readable library name to a specific Context7-compatible ID. This step is necessary to ensure the correct documentation set is targeted.
        - `mcp_context7_get-library-docs`: Fetches the documentation content for a given Context7-compatible library ID. It can be focused on specific topics within the library's documentation.
    - **Design Implication**: Encourages reliance on the latest official documentation, potentially reducing errors from outdated information. Facilitates learning and correct implementation of library features.

This overview serves as a guide for navigating and understanding the project.

## Validation Strategy

The application employs a robust validation strategy to ensure data integrity and provide good user experience.

### Backend Validation (Primary)

-   **Authority**: Backend validation is the authoritative source of truth for data integrity.
-   **Method**:
    -   Primarily, validation is handled using the `rules()` static method within `Spatie\LaravelData\Data` objects (DTOs).
    -   For translatable fields (e.g., `name` defined as `array` in the DTO), validation rules are applied to each locale via dot notation (e.g., `name.en`, `name.zh-TW`). Typically, the application's primary/fallback locale (e.g., `en`) is made `required`, while other locales can be `nullable`.

### Frontend Validation

-   **Purpose**: To provide immediate feedback to the user, improving UX and reducing unnecessary server requests.
-   **Consistency**: Frontend validation rules should mirror backend rules as closely as possible, but backend validation always takes precedence.

## Server Configuration Notes for Robust Form Submissions

Recent debugging experiences with complex forms (particularly those involving file uploads and numerous translatable fields) have highlighted the importance of appropriate PHP server configuration. Issues here can lead to request data being silently truncated or lost before reaching the Laravel application, making it appear as if the frontend is not sending data or the backend is not processing it.

Key `php.ini` directives to be mindful of:

-   **`post_max_size`**: Defines the maximum size of POST data that PHP will accept. If this limit is exceeded (e.g., by a large file upload combined with many other form fields), PHP will stop processing the request data, and `$_POST` and `$_FILES` superglobals (and thus Laravel's `$request->all()`) may be empty or incomplete. This should be set to a value larger than the largest total request payload expected. Example: `64M`.
-   **`upload_max_filesize`**: Defines the maximum allowed size for an individual uploaded file. This must be less than or equal to `post_max_size`. Example: `32M`.
-   **`max_input_vars`**: Limits the maximum number of input variables PHP will accept (e.g., form fields in `$_GET`, `$_POST`, `$_COOKIE`). Complex forms, especially those with array inputs (e.g., `translations[name][en]`, `amenity_ids[]`), can generate a high number of variables. If this limit is exceeded, input variables beyond the limit may be truncated. Default is often 1000; consider increasing for complex applications (e.g., to `3000` or `5000`).
-   **`memory_limit`**: While not directly limiting POST data size, PHP scripts (including request processing) need memory. This should generally be set to a value higher than `post_max_size`. Example: `128M` or `256M`.

**Action**: Always ensure these `php.ini` settings are configured appropriately for the application's needs, especially when deploying or if encountering issues with large/complex form submissions resulting in empty or incomplete request data on the backend. When using tools like Laravel Herd, these settings are managed through Herd's PHP configuration interface. Remember to restart PHP-FPM/webserver after changes.
