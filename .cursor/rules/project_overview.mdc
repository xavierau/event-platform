---
description:
globs:
alwaysApply: true
---
# Project Overview: Laravel 12 Event Platform

This document outlines the structure and conventions for this Laravel 12 project.

## Key Configuration Files:
- **`composer.json`**: Manages PHP dependencies and project metadata. See [composer.json](mdc:composer.json) for details.
- **`package.json`**: Manages Node.js dependencies for frontend assets. See [package.json](mdc:package.json) for details.

## Directory Structure:
This project follows the standard Laravel directory structure:
- **`app/`**: Contains the core code of the application (Models, Controllers, Providers, etc.).
  - **`app/Actions`**: Houses single-responsibility action classes.
  - **`app/DataTransferObjects`**: Contains DTOs, typically built with `spatie/laravel-data`.
  - **`app/Services`**: Holds service classes that encapsulate business logic.
- **`bootstrap/`**: Contains framework bootstrapping scripts and compiled files.
- **`config/`**: Stores all application configuration files.
- **`database/`**: Holds database migrations, seeders, and factories.
- **`public/`**: The web server's document root, containing the `index.php` entry point and compiled assets.
- **`resources/`**: Contains views (Blade templates), raw assets (CSS, JS), and language files.
  - **`resources/js/Pages/Admin/{Entity}`**: Convention for Inertia.js Vue components for admin CRUD interfaces.
- **`routes/`**: Defines all application routes (`web.php`, `api.php`, etc.).
- **`storage/`**: Stores compiled Blade templates, file-based sessions, file caches, and other files generated by the framework.
- **`tests/`**: Contains automated tests (unit, feature).
- **`vendor/`**: Contains Composer dependencies.
- **`node_modules/`**: Contains NPM dependencies.

## Coding Standards:
The application aims to adhere to **SOLID principles** to ensure maintainable, scalable, and robust code.

# Modular Monolithic Design Approach

This project adopts a modular monolithic design. The application will be structured by breaking down the overall system into distinct, self-contained modules.

Each module will encapsulate a specific business capability or domain, aiming for:
- **High Cohesion**: Components within a module are closely related.
- **Low Coupling**: Modules interact with each other through well-defined interfaces, minimizing direct dependencies.

This approach helps in managing complexity, improving maintainability, and allowing for better team scalability as the project grows, while still retaining the deployment simplicity of a monolith.

Key architectural patterns include:
- **Thin Controllers, Fat Models**: Controllers should be lean, delegating business logic to models and other service layers. Models will contain the bulk of the business logic related to data persistence and relationships.
- **Actions**: Single-responsibility classes that encapsulate a specific piece of business logic, often corresponding to a single controller method or a complex operation. For new entities, actions (e.g., `UpsertEntityAction`) are typically created to handle Create/Update logic.
- **Services**: Classes that provide specific functionalities or business logic that doesn't neatly fit into a model or action. They help to keep controllers and models focused. For new entities, a corresponding service (e.g., `EntityService`) is often created to orchestrate actions and provide a comprehensive API for entity lifecycle management (CRUD operations like `createEntity`, `updateEntity`, `deleteEntity`, `findEntity`, `getAllEntities`).
- **Data Transfer Objects (DTOs)**: Simple objects used to transfer data between layers, particularly from requests to actions/services or from services/models back to controllers/responses. This promotes clear data contracts and immutability where appropriate. This project utilizes **`spatie/laravel-data`** for creating these DTOs, enhancing type safety and developer experience.

Following the creation of an entity model, migrations, and seeders, the typical workflow involves:
1.  Defining a `Spatie\LaravelData\Data` object (DTO) in `app/DataTransferObjects/` to represent the data structure for creating/updating the entity.
2.  Creating Action classes in `app/Actions/{EntityName}/` (e.g., `UpsertEntityAction.php`) to handle the core business logic for creating or updating the entity, taking the DTO as input.
3.  Developing a Service class in `app/Services/` (e.g., `EntityService.php`) that uses the Action(s) and provides a clean API for the controller to interact with (e.g., `createEntity(EntityData $data)`, `updateEntity(int $id, EntityData $data)`).
4.  Implementing a Controller in `app/Http/Controllers/Admin/` (e.g., `EntityController.php`) which uses the Service to handle HTTP requests and responses, often rendering Inertia.js views.
5.  Developing frontend Vue components (typically in `resources/js/Pages/Admin/{EntityName}/` like `Index.vue`, `Create.vue`, `Edit.vue`) for the entity's CRUD interface, interacting with the controller endpoints.

## Frontend Development Conventions

- **Mobile-First Design**: The application is designed with a mobile-first approach, ensuring a seamless experience on smaller screens before scaling up to larger displays.
- **Reusable Components**: The frontend will be built with a strong emphasis on creating and utilizing reusable UI components. This ensures a consistent user experience, unified layout, and efficient development. Components should be designed for flexibility and composability.
- **Standardized CRUD Interfaces**: For entities requiring management, corresponding Inertia.js Vue components (e.g., `Index.vue`, `Create.vue`, `Edit.vue` pages) are typically created in the `resources/js/Pages/Admin/{Entity}` directory. These components interact with the backend through the defined Actions and Services via their respective Controllers.

## Project Requirements and Tasks:
- Project requirements and documentation are located in the `prd/` directory.
- Specific tasks and implementation details can be found in [prd/tasks.md](mdc:prd/tasks.md). Please refer to this file for ongoing development tasks.

## Task Management Process

When working on tasks from [prd/tasks.md](mdc:prd/tasks.md):
- **Starting a Task**: Before beginning work, the task status in [prd/tasks.md](mdc:prd/tasks.md) should be updated to "Processing".
- **Completing a Task**: Upon completion, the task status in [prd/tasks.md](mdc:prd/tasks.md) must be updated to "Done" (or "Completed").
- **Status Accuracy**: It is important to ensure task statuses are accurately maintained throughout the development lifecycle.

## Key Libraries and Their Design Implications

Several key libraries are utilized in this project, each influencing design and development practices:

- **`spatie/laravel-translatable`**:
    - **Purpose**: Provides an easy way to manage translatable model attributes.
    - **Design Implication**: Model fields intended for translation (e.g., name, description) must be defined as `JSON` type in database migrations. When accessing these attributes on a model, the library automatically provides the translation for the current application locale. Data for these fields is typically saved as a JSON object with locale keys (e.g., `{"en": "English Text", "zh-TW": "繁體中文文本"}`).
    - **Note on DTO Hydration**: When hydrating a `Spatie\LaravelData\Data` DTO from a model with translatable fields, if the DTO expects these fields as arrays, it's crucial to ensure proper data transformation. Best practice involves:
        1. Explicitly casting the translatable attribute to `'array'` in the model's `$casts` property (e.g., `protected $casts = ['name' => 'array'];`).
        2. In the controller or service, convert the model to an array before passing it to the DTO's `from()` method (e.g., `YourData::from($model->toArray())`). This ensures all accessors and casts are applied correctly.

- **`spatie/laravel-permission`**:
    - **Purpose**: Manages user roles and permissions.
    - **Design Implication**: Requires the `HasRoles` trait to be added to the `User` model (or any model that needs role/permission assignment). Introduces database tables for roles, permissions, and their relationships. Access control can be implemented using provided model methods (e.g., `$user->hasRole('admin')`, `$user->can('edit articles')`) and Blade directives (`@role`, `@can`).

- **`spatie/laravel-data`**:
    - **Purpose**: Enables the creation of rich, type-safe Data Transfer Objects (DTOs).
    - **Design Implication**: DTOs are typically created in `app/DataTransferObjects` and extend `Spatie\LaravelData\Data`. This library facilitates easy creation of DTOs from various sources (e.g., HTTP requests, Eloquent models), handles data validation and casting, and promotes clear data contracts between different layers of the application (e.g., from Controllers to Services/Actions). Translatable fields within DTOs are often represented as arrays with locale keys.
    - **Note on Hydrating from Translatable Models**: When creating a DTO from an Eloquent model that uses `spatie/laravel-translatable` for fields expected as arrays in the DTO (e.g., `public readonly array $name`), ensure the model data is correctly transformed. It's recommended to:
        1. Cast the translatable field to `'array'` in the Eloquent model's `$casts` property.
        2. Convert the model instance to an array using `$model->toArray()` before passing it to the DTO's `from()` method (e.g., `YourData::from($model->toArray())`). This helps avoid TypeErrors where a JSON string might be passed instead of an array.

- **`laravel/cashier`** (Stripe - *Note: Assumed for future use as it's not yet installed*):
    - **Purpose**: Offers an expressive, fluent interface to Stripe's subscription billing services.
    - **Design Implication**: The `User` model (or other billable models) must use the `Billable` trait. This typically adds several columns to the users table (e.g., `stripe_id`, `pm_type`, `pm_last_four`, `trial_ends_at`). It simplifies tasks like creating and managing subscriptions, handling payment methods, and viewing invoices. Requires configuration of Stripe API keys in the `.env` file.

This overview serves as a guide for navigating and understanding the project.

## Validation Strategy

The application employs a robust validation strategy to ensure data integrity and provide good user experience.

### Backend Validation (Primary)

-   **Authority**: Backend validation is the authoritative source of truth for data integrity.
-   **Method**:
    -   Primarily, validation is handled using the `rules()` static method within `Spatie\LaravelData\Data` objects (DTOs). This allows validation rules to be co-located with the data definitions. When a DTO is resolved from an HTTP request in a controller, these rules are automatically applied.
    -   For more complex scenarios not fitting DTO validation or for actions not directly initiated by HTTP requests resolving DTOs, custom Laravel Form Requests can be utilized.
-   **Translatable Fields**: For fields managed by `spatie/laravel-translatable` (e.g., `name`, `description`), validation rules are applied to each locale (e.g., `name.en`, `name.zh-TW`). Typically, the application's primary/fallback locale (e.g., `en`) is made `required`, while other locales can be `nullable`.
-   **Database Constraints**: While application-level validation is comprehensive, database constraints (NOT NULL, UNIQUE, foreign keys) provide a final layer of defense.

### Frontend Validation

-   **Purpose**: To provide immediate feedback to the user, improving UX and reducing unnecessary server requests.
-   **Method**: Frontend forms should implement client-side validation (e.g., using HTML5 attributes, JavaScript libraries, or Vuelidate/Zod with Vue forms).
-   **Consistency**: Frontend validation rules should mirror backend rules as closely as possible, but backend validation always takes precedence.
-   **Error Display**: Inertia.js makes backend validation errors available to the frontend, which should be displayed clearly next to the relevant form fields.
